# 1.2. 왜 아직도 자바는 변화하는가?

- 우리는 시공을 초월하는 완벽한 언어를 원하지만, 현실적으로 그런 언어는 존재하지 않는다.
- 모든 언어는 장단점을 가지고 있다.
  > 📌 **예시**
  > - C, C++
  > 	- 장점 : 작은 런타임 풋프린트 - 운영체제와 다양한 임베디드 시스템에서 인기를 끌고 있음
  > 	- 단점 : 낮은 프로그래밍 안전성 - 프로그램이 예기치 않게 종료되거나 바이러스 등이 침투할 수 있는 보안 구멍이 있을 수 있음
  > - Java, C#
  > 	- 안전성 ↑ - 런타임 풋프린트에 여유가 있는 어플리케이션에서는 C, C++을 압도함

- 새로운 언어가 등장하면 진화하지 않은 기존 언어는 사장된다. 
- 단, Java는 1995년 첫 베타 버전이 공개된 이후로 경쟁 언어를 대신하며 커다란 생태계를 성공적으로 구축했다.
- Java 8의 3가지 프로그래밍 개념을 조금 더 자세히 알아보자.
  1) Stream
  2) Behavior Parameterization
  3) Shared Mutable Data & Parallelism

<br>

## 1.2.1 프로그래밍 언어 생태계와 Java

### Java의 출발
- 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작
- 처음부터 스레드, 락을 이용한 동시성도 소소하게 지원했음
- 코드를 JVM 바이트 코드로 컴파일함 → Java가 인터넷 애플릿 프로그램의 주요 언어가 됨
- 다양한 임베디드 컴퓨팅 분야(스마트카드, 토스터, 셋톱박스, 자동차 브레이크 시스템 등)를 성공적으로 장악 중
  > **📌 참고**<br>
  > Scala, Groovy와 같은 경우, 중요도가 `JVM(자바 가상 머신)`, `바이트코드` > `Java 언어`일 경우 Java를 대체하기도 했음!
  > 특히, JVM의 최신 업데이트 덕분에 경쟁 언어는 JVM에서 더 부드러운 실행이 가능해짐 + 자바와 상호동작도 가능해짐

### Java와 객체지향
- 객체지향은 1990년대, 두 가지 이유로 각광 받음
  1. **캡슐화** - C에 비해 소프트웨어 엔지니어링적인 문제 ↓
  2. 객체 지향의 **정신적 모델** - 윈도우 95 ~ 의 WIMP 프로그래밍 모델에 쉽게 대응할 수 있었음
- 초기 브라우저들에서 Java 모델과 Java 코드 애플릿을 안전하게 실행할 수 있었음
   → 자바가 대학으로 깊숙히 자리 잡음
   → 졸업생들이 업계에서 활용하기 시작
- 하드웨어가 발전함에 따라 `프로그래머의 시간`이 `애플리케이션 실행 시간`보다 더 중요한 요소로 부각되었고, Java가 더욱 힘을 얻음

### Java도 마주한 새로운 바람
#### 1) 병렬 프로세싱
- 프로그래머들이 빅데이터(TB 이상의 DataSet)를 직면하며, **멀티코어 컴퓨터**와 **컴퓨팅 클러스터**의 필요성이 커짐
- Java 8 - 더욱 다양한 프로그래밍 도구 제공
  - 자바에 없던 완전히 새로운 개념들을 추가 → 현재 시장에서 요구하는 기능을 효과적으로 제공
  - 멀티코어 병렬성이 강화됨

#### 2) 큰 시스템 설계
- 외부에서 큰 하위시스템 컴포넌트를 추가하고, 다른 벤더가 만든 컴포넌트를 이용해 개발하는 사례 ↑
- Java 8 - default 메소드 제공
- Java 9 - module 제공

<br>

## 1.2.2 Stream Processing (스트림 처리)

#### **Stream**
: 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임
- 프로그램 : 입력 스트림에서 데이터를 한 개씩 읽어 들이고, 출력 스트림으로 데이터를 한 개씩 기록함
  ⇒ 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있음
  > - 입력 스트림 : `System.in`
  > - 출력 스트림 : `System.out`

#### Unix의 병렬 실행
```unix
// 파일의 단어를 소문자로 바꾼 후, 사전 순으로 단어를 정렬했을 때 마지막 3개 단어 출력
cat file1 file2 | tr "[A-Z]" "[a-z]" | sort | tail -3
```
- `sort` : 여러 행의 스트림을 입력으로 받아, 여러 행의 스트림을 출력으로 만들어냄
  - 따라서, `cat`, `tr`이 완료되지 않은 시점에서 sort가 행을 처리하기 시작할 수 있음

#### Java의 병렬 처리
- Java 8 - java.util.stream 패키지에 스트림 API가 추가됨
  - `Stream<T>` : T 형식으로 구성된 일련의 항목을 의미함

- **복잡한 파이프라인 처리**
  - 위의 Unix 명령어가 복잡한 파이프라인을 구성했던 것처럼, 스트림은 파이프라인을 만드는 데에 필요한 많은 메서드를 제공함
  - 기존에는 한 번에 한 항목을 처리했던 반면, Java 8 이후에는 (마치 DB 쿼리처럼) 작업을 고수준으로 추상화해서 일련의 스트림으로 처리 가능해짐

- **여러 CPU 코어에 할당**
  - 스트림 파이프라인을 이용해서, 입력 부분을 여러 CPU 코어에 쉽게 할당 가능
  - 스레드를 사용하지 않고도 공짜로 병렬성을 얻을 수 있음

<br>

## 1.2.3. Behavior Parameterization (동작 파라미터화)

#### Behavior Parameterization
- 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블럭 (코드 블럭의 실행은 나중으로 미뤄짐)
  ⇒ 코드 블럭에 따라 메서드의 동작이 파라미터화됨
- 즉, 메서드를 다른 메서드의 인수로 넘겨주는 기능

#### Java 8
- Java 8 이전에는 메서드를 다른 메서드로 전달할 방법이 없었음
- Java 8 이후 동작 파라미터화로 인해, 코드 일부를 API로 전달하는 기능이 가능해짐
  즉, 메서드(코드)를 다른 메서드의 인수로 넘겨주는 것이 가능
- 함수형 프로그래밍 분야의 기술을 응용해서 동적 파라미터를 활용하는 방법도 있음

> 💡 **동작 파라미터화**가 중요한 이유!<br>
> Stream API는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초하기 때문

<br>

## 1.2.4. Shared Mutable Data & Parallelism (공유 가변 데이터와 병렬성)

#### 공짜 병렬성?
- 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꾸면 병렬성을 공짜로 얻을 수 있음

#### 스트림과 병렬성
- 스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행되더라도 안전하게 실행될 수 있어야 함
- 공유된 변수나 객체가 있으면 병렬성에 문제 발생! (ex: 두 개의 프로세스가 공유된 변수를 동시에 바꿀 때?)

#### Synchronized vs Stream
- **`synchronized`** (~ Java 7)
  - 공유된 가변 데이터 보호 규칙 생성 가능
  - 단, 시스템 성능에 악영향 有 - 다중 프로세싱 코어에서 사용시 아주 비효율적일 수 있음
- **`stream`** : 기존의 스레드 API보다 쉽게 병렬성 활용 가능

#### 병렬성 있는 코드
- 다른 코드와 동시에 실행하더라도 안전하게 실행할 수 있는 코드를 만들려면 **공유된 가변 데이터(shared mutable data)** 에 접근하지 않아야 함
- 이러한 코드들을 순수 함수(pure function), 부작용 없는 함수(side-effect-free function), 상태 없는 함수(stateless function)라고 부름
- 함수형 프로그래밍 패러다임의 핵심적인 사항 ( ↔ 명령형 프로그래밍 : 일련의 가변 상태로 프로그래밍을 정의함)
  > 즉, 함수가 (수학적인 함수처럼) 정해진 기능만 수행하며, 다른 부작용은 일으키지 않는다는 개념과 관련이 있음!

<br>

## 1.2.5. 자바가 진화해야 하는 이유

#### Java의 진화
1. (Java 5) `Generic`의 출현
   - 컴파일 시 더 많은 에러를 검출할 수 있음
   - `List` → `List<String>` - 리스트의 유형을 알 수 있어 가독성이 좋아짐

2. (Java 8) 고전적인 객체 지향에서 벗어나, 함수형 프로그래밍으로 다가섬
   - 함수형 프로그래밍 - 우리가 하려는 작업이 최우선시되며, 그 수행 방법은 별개로 취급함
   - `Iterator` → `for-each`
   <br>
   
    > 극단적으로 생각하면 전통적인 객체지향 프로그래밍과 함수형 프로그래 밍은 완전 상극이다. 자바 8에서 함수형 프로그래밍을 도입함으로써 두 가지 프로그래밍 패러다임의 장점을 모두 활용할 수 있게 되었다.
    > ⇒ 즉, 어떤 문제를 더 효율적으로 해결할 수 있는 다양한 도구를 얻게 된 것!
  
#### 결론
언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다!
