# 5.5 리듀싱

- 리듀싱이라는 단어는 “줄이다”라는 의미를 가진다.
- 스트림에서 리듀싱은 스트림의 모든 요소를 하나의 값으로 줄이는 작업을 수행한다.
- `메뉴에서 칼로리가 가장 높은 요리는?`,`메뉴의 모든 칼로리의 합계는?`처럼 모든 스트림 요소를 반복적으로 처리해서 결과를 도출하는 작업을 수행할 수 있다.

## 사용 목적

- 리듀싱은 대개 스트림의 모든 요소를 하나의 값으로 합치기 위해 사용된다.
    - 총합
    - 평균값
    - 최댓값
    - 최솟값

`reduce`는 두 개의 인수를 갖는다.

- 초기값
- 스트림의 두 요소를 합쳐서 하나의 값으로 만드는데 사용할 람다

## 5.5.1 요소의 합

먼저 for-each 루프를 이용해서 리스트의 숫자 요소를 더하는 코드를 확인해보자.

```java
int sum = 0;
for (int x : numbers) {
	sum += x;
}
```

위 코드는 reduce를 사용해서 다음과 같이 변경할 수 있다.

```java
int sum = numbers.stream().reduce(0, (a,b) -> a + b);
```

메서드 참조로 Integer 클래스의 sum 메서드를 사용하면 더 간결하게 구현 가능하다.

```java
int sum = numbers.stream().reduce(0, Integer::sum);
```

### 초기값 없음

초기값을 받지 않도록 오버로드된 reduce도 있다. 하지만 이 reduce는 Optional 객체를 반환한다.

```java
Optional<Integer> sum = numbers.stream().reduce(Integer::sum);
```

스트림에 아무 요소도 없다면 초깃값이 없으므로 reduce는 합계를 반환할 수 없기 때문이다.

## 5.5.2 최댓값과 최솟값

reduce 연산은 새로운 값을 이용해서 스트림의 모든 요소를 소비할 때까지 람다를 반복 수행한다.

이를 통해 최댓값과 최솟값을 찾을 때도 reduce를 활용할 수 있다.

```java
Optional<Integer> max = numbers.stream().reduce(Integer::max);
```

### reduce 메서드의 장점
기존의 단계적 반복으로 합계를 구하는 것 vs reduce를 이용하는 것의 차이
- 스트림의 reduce 사용시 : 내부 반복이 추상화되면서 내부 구현에 벙렬로 reduce를 실행할 수 있게 된다.
- 기존의 단계적 반복 : 예) sum 변수를 공유해야 하므로 쉽게 병렬화하기 어렵다.

### 병렬 처리시 주의 사항
>reduce의 초기값으로 인해서 의도되지 않은 결과가 나올 수 있다.<br>
>`parallel()` 키워드를 붙임으로써 병렬로 처리되도록 할 수 있다.<br>
> reduce가 아니더라도 병렬 처리를 했을 때 결과에 영향을 줄지에 대한 확인이 반드시 필요하다.
### 스트림 연산 : 상태 있음과 상태 없음
- 상태 있음 : 이전 요소와 관련된 정보를 저장하는 데 사용되는 것
- 상태 없음 : 각 요소를 독립적으로 처리하며, 이전 요소와 관련된 정보를 유지하지 않는 

스트림 연산은 각각 다양한 작업을 수행한다. 따라서 각각의 연산은 내부적인 상태를 고려해야한다.

`map`, `filter`등은 입력 스트림에서 각 요소를 받아 0 또는 결과를 출력 스트림으로 보낸다.<br>
따라서 이들은 보통 상태가 없는, 즉 `내부 상태를 갖지 않는 연산(stateless operation)`이다.

`reduce`, `sum`, `max` 같은 연산은 결과를 누적할 내부 상태가 필요하다. 하지만 내부 상태는 int, double등과 같이 작은 값이며, 스트림에서 처리하는 요소 수와 관계없이 한정(bounded)되어 있다.

반면 `sorted`나 `distinct` 같은 연산을 수행하기 위해서는 과거의 이력을 알고있어야 한다.<br> 
예를 들어 어떤 요소를 출력스트림으로 추가하려면 `모든 요소가 버퍼에 추가되어 있어야 한다.`<br>
따라서 데이터 스트림의 크기가 크거나 무한이라면 문제가 생길 수 있다. 이러한 연산을 `내부 상태를 갖는 연산(stateful opertaion)`이라 한다.
>상태 있음 연산은 일부 작업을 수행할 때 유용하다.<br>
>반면에 상태 없음 연산은 각 요소를 독립적으로 처리하고 이전 요소와 관련된 정보를 유지하지 않아도 되므로, 병렬 처리에 적합하며 데이터 처리 파이프라인에서 사용하기에 효율적이다.