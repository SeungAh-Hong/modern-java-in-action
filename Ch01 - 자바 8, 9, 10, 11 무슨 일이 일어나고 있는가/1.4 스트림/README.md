# 1.4 스트림

거의 모든 자바 애플리케이션은 컬렉션을 **만들고 활용한다**.
하지만 컬렉션으로 모든 문제가 해결되는 것은 아니다.
예를 들어 고가의 트랜잭션만 필터링한 다음 통화로 결과를 그룹화 해보자.

```java
private static void Transaction() {
        // todo :: 그룹화된 트랜잭션을 더할 Map 생성
        Map<Currency, List<Transaction>> transactionsByCurrencies = new HashMap<>();

        // todo :: 트랜잭션 리스를 반복
        for (Transaction transaction : transactions) {
            if (transaction.getPrice() > 100) {
                // todo :: 트랜잭션의 통화 추출
                Currency currency = transaction.getCurrency();
                List<Transaction> transactionsForCurrency = transactionsByCurrencies.get(currency);

                // todo :: 현재 통화의 그룹화된 맵에 항목이 없으면 새로 만든다.
                if (transactionsForCurrency == null) {
                    transactionsForCurrency = new ArrayList<>();
                    transactionsByCurrencies.put(currency, transactionsForCurrency);
                }

                // todo :: 현재 탐색된 트랜잭션을 같은 통화의 트랜잭션 리스트에 추가한다.
                transactionsForCurrency.add(transaction);

            }
        }
    }
```

다음처럼 많은 코드를 구현해야하고, 가독성이 떨어져 알아보기도 이해하기도 힘들다.
위의 코드를 보면 같은 항목이 중첩된 제어 흐름 문장이 많아 더욱 더 한번에 이해하기 난해하다.

그럼 **스트림 API**를 이용하여 다음 문장을 해결해보자.

```java
private static void Transcation() {
        Map<Currency, List<Transaction>> transactionsByCurrencies =
                transactions.stream()
                        .filter((Transaction t -> t.getPrice() > 1000) // 고가의 트랜잭션 필터링
                        .collect(groupingBy(Transaction::getCurrency)); // 통화로 그룹화함
    }
```

지식이 없다면 위 코드를 이해하기 어렵다.
이후에 더 자세히 스트림에 대해 설명할테니 지금은 스트림 API를 활용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를
처리 할 수 있다는 사실만 기억하자.

컬렉션에서는 반복 과정을 직접처리해야 했다.

즉, for-each 문을 사용해 각 요소를 반복하면서 작업을 수행했다.
즉 컬렉션의 요소를 반복문을 통해 직접 탐색하는 것이다.
이런 방식의 반복을 **외부 반복**이라고 한다.

반면 스트림 API를 이용하면 이러한 루프를 신경 쓸 필요가 없다.
스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다.
이와 같은 반복을 **내부 반복**이라고 한다.

나중에 스트림에 대해 깊게 배우겠지만 먼저 간단히 소개하자면
스트림이 알아서 반복을 처리하고 그 결과를 어딘가에 따로 저장한다.
스트림의 내부 반복은 람다 표현식을 인수로 받기 때문에, 어떤 작업을 수행할지만 지정하면 모든 것이 알아서 처리된다.

조금 이해하기 쉽게 설정하자면 컬렉션의 **내부 반복**은 어떤 상자에 아이템을 담아야 할때, 아이템을 하나씩 담아야 한다면
스트림의 **외부 반복**은 어떤 상자에 아이템을 담아야 할때, 병렬적으로 동시에 담을 수 있다.

이러한 차이점은 멀티코어 컴퓨터에서 더욱 두드러진다.

컬렉션으로 방대한 요소를 가진 목록을 반복한다면 단일 CPU로 처리되어 시간이 오래 걸릴 수 있다.
하지만 스트림은 어떤가 코어가 8개인 CPU라면 8개의 코어를 전부 사용해 병렬적으로 작업을 수행하기에 컬렉션보다 8배 빠르게 작업할 수 있다!


## 1.4.1 멀티스레딩은 어렵다.

이전 자바 버전에서 제공하는 스레드 API로 멀티스레딩 코드를 구현해서 병렬성을 이용하는 것은 쉽지않다.
멀티스레드 환경에서는 동시에 공유된 자원에 접근하고, 데이터를 갱신할 수 있다.

결과적으로 스레드를 잘 제어하지 못하면 원치않은 방식으로 데이터가 바뀔 수 있다.

말로 한번 풀어보자.

우리는 2가지의 스레드를 예시로 사용할 것이다.

스레드1, 스레드2 그리고 
이 두 개의 스레드가 공유할 자원인 int = 100 이 있다.

위에서 잠깐 설명했듯이 멀티스레드 환경에서는 공유된 자원에 동시에 접근한다.

```멀티스레드
1. 스레드1이 공유된 자원 100에 접근했다.
2. 스레드2도 공유된 자원 100에 접근했다.
3. 스레드1이 공유된 자원 100을 103으로 수정했다.
4. 스레드1이 변경한 공유 자원 103을 저장했다. (+3)
5. 그럼 스레드2가 공유 자원이 103으로 변경된 것을 알 수 있을까? 이미 변경전에 공유 자원 100을 가지고 오는 처리를 했는데???
6. 스레드2가 이미 가져온 공유된 자원 100을 105로 수정했다. (+5)
7. 스레드2가 변경한 공유 자원 105을 저장했다.
8. 스레드1이 (+3)을 했고, 스레드2가 (+5)를 공유된 자원에 각각 했으니 결과값은 108인가?
9. 아니다 각자 처음에 공유된 자원을 가지고 가장 마지막에 처음 받은 공유 자원 100을 수정한 결과값인 105로 수정된다.
10. 이건 우리가 원하는 결과가 아니다.
```

자바8의 스트림 API는 컬렉션으로 자료를 처리할 때 생기는 모호함과 반복적인 코드 문제
그리고 멀티코어 활용의 어려움 이라는 문제는 모두 해결했다.

처음 컬렉션으로 작성된 코드를 보면 무언가 비슷한 코드가 반복되는 것을 확인할 수 있다.
이처럼 스트림은 자주 반복되는 패턴으로 주어진 조건에 따라 **필터링**을 하거나, 데이터를 **추출**하거나, 데이터를 **그룹화**하는 기능이 있다.

또 하나 예시를 들어보자.

```
두 개의 멀티코어를 가진 컴퓨터(2개의 CPU를 가진 컴퓨터)에서 리스트를 필터링 할때, 
하나의 CPU는 필터링 해야할 리스트의 앞부분을, 또 하나의 CPU는 필터링 해야할 리스트의 뒷부분을 처리하도록 요청할 수 있다.
이것을 **포킹 단계**라고 한다. 병렬처리!!

그리고 각각의 CPU는 맡은 부분을 처리한다.

각각의 CPU가 작업을 처리한 후 하나의 CPU가 두 결과를 정리힌다.
```

지금은 스트림 API나 컬렉션 API나 비슷한 동작 방식을 가지고 있다고 생각할 수도 있다.
중요한건 **컬렉션은 어떻게 데이터에 접근하고 데이터를 저장하는데 초점이 맞춰져 있는 반면**,
**스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다는 것을 명심하자**

또한 스트림은 스트림 내의 요소를 쉽게 병렬처리하게 환경을 제공한다는 것이 핵심이다.

다시 한번 언급하지만 스트림과 람다 표현식을 이용하면 '병렬성을 공짜로' 얻을 수 있다.
하지만 데이터가 적은 부분에서는 스트림으로 병렬 처리하는 것이 성능이 더 나쁠 수 있다.

```java
// 스트림으로 구현한 단순 순차 처리 (병렬 처리 아니에요)
List<Apple> heavyApples = 
            inventory.stream().filter((Apple a) -> a.getWeight() > 150)
                    .collect(toList());
                    
// 스트림으로 구현한 병럴 처리
List<Apple> heavyApples =
            inventory.parallelstream().filter((Apple a) -> a.getWeight() > 150)
                    .collect(toList());
```
